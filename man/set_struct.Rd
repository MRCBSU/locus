% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/prepare_locus.R
\name{set_struct}
\alias{set_struct}
\title{Gather settings for application of the `locus` function with structured
sparse prior.}
\usage{
set_struct(n, p, pos_st, n_cpus, verbose = TRUE)
}
\arguments{
\item{n}{Number of samples.}

\item{p}{Number of candidate predictors.}

\item{pos_st}{Vector gathering the predictor block positions (first index of
each block). The predictors must be ordered by blocks.}

\item{n_cpus}{Number of CPUs to be used. Only used if \code{hyper} is 
\code{FALSE}, otherwise set it to 1. If large, one should ensure that 
enough RAM will be available for parallel execution. Set to 1 for serial 
execution.}

\item{verbose}{If \code{TRUE}, messages are displayed when calling
\code{set_struct}.}
}
\value{
An object of class "\code{struct}" preparing the settings for group
  selection in a form that can be passed to the \code{\link{locus}}
  function.
}
\description{
[FUNCTIONALITY UNDER ACTIVE DEVELOPMENT, PERFORMANCE (CPU TIME) NOT OPTIMIZED].
Posterior probabilities of associations are computed using an empirical
covariance estimate of the candidate predictors. This estimate has a block
structure (which could reflect linkage disequilibrium patterns when
considering genome-wide associations). Such a structure is necessary in
large problems for tractability both time- and memory-wise. The posterior
probablity of inclusion corresponding to a given block are approximated by a
multivariate distribution through a Bernoulli-probit link function.
}
\examples{
seed <- 123; set.seed(seed)

###################
## Simulate data ##
###################

## Example using small problem sizes:
##
n <- 200; p <- 300; p0 <- 100; d <- 50; d0 <- 40

## Candidate predictors (subject to selection)
##
# Here we simulate common genetic variants (but any type of candidate
# predictors can be supplied).
# 0 = homozygous, major allele, 1 = heterozygous, 2 = homozygous, minor allele
#
X_act <- matrix(rbinom(n * p0, size = 2, p = 0.25), nrow = n)
X_inact <- matrix(rbinom(n * (p - p0), size = 2, p = 0.25), nrow = n)

shuff_x_ind <- sample(p)
X <- cbind(X_act, X_inact)[, shuff_x_ind]

bool_x_act <- shuff_x_ind <= p0

pat_act <- beta <- matrix(0, nrow = p0, ncol = d0)
pat_act[sample(p0*d0, floor(p0*d0/5))] <- 1
beta[as.logical(pat_act)] <-  rnorm(sum(pat_act))

## Gaussian responses
##
Y_act <- matrix(rnorm(n * d0, mean = X_act \%*\% beta, sd = 0.5), nrow = n)
Y_inact <- matrix(rnorm(n * (d - d0), sd = 0.5), nrow = n)
shuff_y_ind <- sample(d)
Y <- cbind(Y_act, Y_inact)[, shuff_y_ind]

########################
## Infer associations ##
########################

n_st <- 100
pos_st <- seq(1, p, by = ceiling(p/n_st))
list_struct <- set_struct(n, p, pos_st, n_cpus = 1)

vb <- locus(Y = Y, X = X, p0_av = p0, link = "identity",
   list_struct = list_struct, user_seed = seed)

}
\seealso{
\code{\link{locus}}
}
